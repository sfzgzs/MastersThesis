
Let us review the the \WhileCCprogramminglanguage{} over an \Nstandardsignature{} $\Sigma$. We will be working on the model based on the \WhileCC{} programming language over \mathcalR. 
A prominent feature of this language is the $\chooseOp$ operator which selects a natural number satisfying a computable predicate.
% The $\chooseOp$ operator is inherently nondeterministic.
As \citet{AbstractVSConcreteComputationOnMetricPartialAlgebras_TuckerZucker_2004} show, any abstract model for computing functions on topological algebras, needs to have partial operations and computable functions that are continuous and multi-valued even to be able to compute deterministic problems. Hence, having a nondeterministic countable choice operation $\chooseOp$ here is a feature and not a bug! 

\subsection{Syntax}
\begin{definition}[\WhileCCprogramminglanguagesyntax{}, \citep{AbstractVSConcreteComputationOnMetricPartialAlgebras_TuckerZucker_2004}]
\label{def::whileCCsyntax}
    For any \Nstandardalgebra{} $\Sigma$, we define four syntactic classes:
    \begin{enumerate}[(a)]
        \item 
        $\SIGMA$\textbf{-variables} (written  $\VarOfSigma$):\\
        The class of $\VarOfSigma$ consists of variables of each sort $s \in \SortOfSigma$.
        For each $s\in \SortOfSigma$, $\mathbf{Var_s}$ denotes the class of variables of sort $s$: $\VarOfSigma = \cup_{s\in \SortOfSigma}\mathbf{Var_s}$.
        
        \item
        $\SIGMA$\textbf{-terms} (written $\TermOfSigma$):\\
        For each  $s\in \SortOfSigma$, terms are generated by:
        \[t^s ::= x^s\ \mid F(t_1^{s_1}, \ldots , t_m^{s_m}) \]
        where $F$ is a $\Sigma$-function of type $s_1 \times \cdots \times s_m \to s$ (written $F:s_1 \times \cdots \times s_m \to s$) and $s_1, \ldots, s_m, s\in  \mathbf{Sort(\Sigma)}$
        
        \item
        $\SIGMA$\textbf{-statements} (written $\StatementOfSigma$):
        Statements are generated by:
        \begin{align*}
            S ::=  \mathsf{skip}\
                    &\mid \diverge
                    \mid \bar{x} := \bar{t}
                    \mid S_1\ S_2
                    \mid \mathsf{if}\ b \ \mathsf{then}\ S_1 \ \mathsf{else}\ S_2\ \mathsf{fi}\ \\
                    &\mid \mathsf{while}\ b\ \mathsf{do}\ S_0\ \mathsf{od}
                    \mid n:= \mathsf{choose\ } (z: \nat): P(z,\bar{t})
        \end{align*}
        where $b$ is of type $\mathsf{bool}$ and  $\bar{x} := \bar{t}$ denotes valid concurrent assignment i.e., $\bar{x}$ is a tuple of \textit{distinct} variables and $\bar{t}$ is a tuple of $\Sigma\textbf{-terms}$. Also, $n$ and $z$ are of type $ \nat$, $P$ is a procedure of type $\nat\times \bar{w}\to \mathsf{bool}$, and $\bar{t}$ is of type $\bar{w}$.
        
        \item
        $\SIGMA$\textbf{-procedures} (written $\ProcOfSigma$):\\
        Procedures of type $\bar{u} \to \bar{v}$ are generated by:
        \begin{center}
        \label{procNameAdded}
            $P$ ::= $\mathsf{proc} \ D\ \mathsf{begin}\ S\ \mathsf{end}$
        \end{center}
        where $S$ is the body (all the variables in the body $S$ should be defined in $D$), and $D$ is the variable declaration of the form:
        \[
        D ::= \mathsf{in}\ \bar{a}:\bar{u}\ \mathsf{out}\ \bar{b}:\bar{v}\ \mathsf{aux}\ \bar{c}:\bar{w}
        \]
        with $\bar{a},\bar{b} $ and $\bar{c}$ being tuples of input, output, and auxiliary (distinct and pairwise disjoint) variables respectively of type $\bar{u}$, $\bar{v}$, and $\bar{w}$. Note that the $\mathsf{aux}$ clause can be omitted when $\abs{\bar{c}} = 0$.
    \end{enumerate}
\end{definition}
\begin{remark}
    In this thesis, we exclusively work with \WhileCC($\algebraR$) programming language.
    So whenever \WhileCC{} is mentioned without specifying a standard algebra, we mean \WhileCC($\algebraR$).
\end{remark}
\begin{remark}
\label{remark::syntactic_equality}
    In the current setup of the language, we do not introduce names for procedures inside the grammar. Instead, we 
    define shorthands at the metalanguage level for procedures explicitly (using the $\equiv$ operator) or implicitly ( ``Let procedure $P$ be as follows, etc.''). These shorthands allow us to make the syntax more readable without complicating the grammar.
    For example, instead of writing 
     \[
    \BLOCK{
        \PROC \\
        \INDENT{
            \IN n : \nat \\
            \OUT r : \bool \\
            \AUX k : \nat} \\
        \BEGIN \\
        \INDENT{
            r := \CHOOSE (k : \nat) :
            \BLOCK{
                \PROC \\
                \INDENT{
                    \IN m : \nat\ n : \nat \\
                    \OUT \res : \bool} \\
                \BEGIN \\
                \INDENT{
                    \IF n \natEq 2 \natTimes m \THEN \\
                    \INDENT{\res := \true} \\
                    \ELSE \\
                    \INDENT{\res := \false} \\
                    \FI} \\
                \END(k, n)}} \\
        \END}
    \]
    we can define a shorthand for the inner procedure
\[
    \mathsf{ExampleProc} \equiv \BLOCK{
        \PROC \\
        \INDENT{
            \IN m : \nat\ n : \nat \\
            \OUT \res : \bool} \\
        \BEGIN \\
        \INDENT{
            \IF n \natEq 2 \natTimes m \THEN \\
            \INDENT{\res := \true} \\
            \ELSE \\
            \INDENT{\res := \false} \\
            \FI} \\
        \END}
\]
    and then the main procedure could be changed into the following:
\[
    \BLOCK{
        \PROC \\
        \INDENT{
            \IN n : \nat \\
            \OUT r : \bool \\
            \AUX k : \nat} \\
        \BEGIN \\
        \INDENT{
            r := \CHOOSE (k : \nat) : \mathsf{ExampleProc}(k, n)} \\
        \END}
\]
\end{remark}
\paragraph*{\large{Notation.}}
\label{subsubsection::notation}
For expressions $X_1, \ldots, X_n$, we write $X_1<X_2<\cdots<X_n$ as a shorthand for $X_1<X_2 \boolAnd X_2<X_3 \boolAnd \cdots \boolAnd X_{n-1}<X_n$. 
We use $1/x$ as a shorthand for $\realInv(x)$, $x/y$ for $x\ \realTimes\ (1/y)$, $-x$ for $(\realMinusOne \ \realTimes\ x)$, and  $x - y$ for $x \ \realPlus\ (-y)$.
We omit the subscripts on $\natPlus$ and $\realPlus$ (resp. $\natTimes$ and $\realTimes$) since the appropriate subscript can be inferred from the argument types. 
Also, we write $\mathsf{if}\ b \ \mathsf{then}\ S_1 \ \mathsf{fi}$ as a shorthand for $\mathsf{if}\ b \ \mathsf{then}\ S_1 \ \mathsf{else\ skip}\ \mathsf{fi}$.
We write $n:= \mathsf{choose\ } (z:\nat): t$ as a shorthand for 
\[n:= \mathsf{choose\ } (z:\nat): \mathsf{ProcP}(z, \ldots )\]
where $t$ is a $\Sigma$-term and $z$ may appear free in $t$ and $\mathsf{ProcP}$ is:
\[
    \BLOCK{
        \PROC \\
        \INDENT{
            \IN z : s \ldots \\
            \OUT r : \bool} \\
        \BEGIN \\
        \INDENT{
            r := t} \\
        \END}
\]

% \edcomm{FG}{Would it help clarify the $\chooseOp (z : \real)$ issue if I re-order the subsubsections and add more explanation as well as the corrections below?}

% \edcomm{WK}{You currently appear to have a coherent story (except for my next comment),
% so it is up to you how you want to sequence the presentation of the extensions.}

\paragraph*{\large Procedure Call Statements.}
\label{par::procedure_calls}
Note that our definition of \WhileCC-syntax does not involve any procedure calls other than within a $\chooseOp$ statement.
We extend our rules of statement generation to include procedure calls of the form 
\[\bar{u} := P(\bar{t})\]
where $P$ is a procedure of type $\bar{s} \to r$ with $\bar{t}$ a tuple of terms of type $\bar{s}$ and $u$ is a variable of type $r$. A procedure call is syntactic sugar for copying the body of the called procedure $P$ into the calling procedure with any necessary variable renaming, initializing $P$' s input variables with the term(s) $\bar{t}$ and copying the output(s) into variable(s) $\bar{u}$.
Therefore, there are no recursive procedure calls.
Note that procedure calls do \textit{not} computationally strengthen our model.
In the following sections, any appearance of procedure $P$ in an expression
\[
    \bar{x} := \cdots P(\bar{t})\cdots
\]
is a short form of 
\begin{align*}
    \bar{y} &:= P(\bar{t})\\
    \bar{x} &:= \cdots \bar{y} \cdots 
\end{align*}
for some fresh tuple $y$ of the same type as the output type of $P$. 

\paragraph*{\large Casting $\nat$ to $\real$.}
We present a \WhileCC-program that maps each natural number to its equivalent real number below:
\[
  \mathsf{toReal} \equiv
            \BLOCK{
            \PROC \\
                \INDENT{
                \IN n:\nat \\
                \AUX \counter:\nat\ \summ:\real }\\
           \BEGIN \\
                \INDENT{
                \summ := \realZero \\
                \counter := \natZero\\
                \WHILE \counter \natLess n \DO \\
                    \INDENT{
                   \summ := \summ + \realOne   \\
                   \counter := \counter + \natOne}\\
               \OD \\
               \RETURN \summ} \\
           \END}\\
\]
From here on, we implicitly make use of this mapping whenever we input anything of type $\nat$ as a $\real$ argument (namely assigning $\nat$ values to $\real$ variables).


\paragraph*{\large Choosing Multiple $\nat$ Values.}
\label{par::choose_multiple_nat_var}
In this thesis, we define the shorthand
\[
    \bar{x} := 
    \CHOOSE (z_1:\nat, \ldots , z_n:\nat): P(\bar{z}, \bar{t}) 
\]
for $\chooseOp$ for multiple distinct variables where procedure $P$ is of type 
\[
\overbrace{\nat\times \cdots \times\nat}^{n \text{ times}} \times \bar{s} \to \bool,\]
and $\bar{t}$ is a tuple of terms of type $\bar{s}$. This shorthand stands for
\[
    \BLOCK{
    x_{1} := \CHOOSE (z_{1}:nat) : 
                    \BLOCK{
                    \PROC\\
                        \INDENT{
                        \IN z_{1} : \nat \ \bar{r} : \bar{s}\\
                        \OUT \res : \bool\\
                        \AUX \tmp_{2} : \nat \ldots \tmp_{n} : \nat
                        }\\
                    \BEGIN\\
                    \INDENT{
                        \tmp_{2}, \ldots , \tmp_{n} := \\
                        \INDENT{
                        \CHOOSE (z_2:\nat,\ldots,z_n: \nat) : P(\bar{z},\bar{r})}\\
                        \res := \true}\\
                    \END (z_{1}, \bar{t})}\\
    x_{2},\ldots ,x_{n} := \CHOOSE (z_{2}:\nat,\ldots,z_n:\nat) : P(x_{1},z_{2},\ldots ,z_{n},\bar{t})\\}
\]
Note that this notation is defined recursively, i.e., $\chooseOp$ with $n$ variables of type $\nat$ is defined in terms of $\chooseOp$ with $n-1$ variables. This definition is by no means efficient: in fact this recursive definition leads to an exponential number of calls to $\chooseOp$. For $n$ variables, $\chooseOp$ with one variable is executed $2^n-1$ times rather than just once. The reason is that the procedure $P$ needs all the arguments to be chosen simultaneously.

An alternative approach that addresses the inefficiency concern would be to encode each $n$-tuple as a single natural number using 
 G\"odel's numbering, choose the GÃ¶del
number of the output tuple, and then decode it to obtain each value.
This would reduce the number of calls to $\chooseOp$ to only one. While this is certainly feasible, the efficiency is not our main concern here. Our primary goal here is to establish that $\chooseOp$ can be extended to multiple variables without adding computational power to our language. A similar idea for the extension is mentioned in \citet{AbstractVSConcreteComputationOnMetricPartialAlgebras_TuckerZucker_2004} for choosing ``pairs'' of natural numbers using primitive recursive pairing and projection functions. 

% \edcomm{WK}{So, unless I misunderstand the semantics of choose,
% choose with one variable will be executed $2^{n-1}$ times?}
% \edcomm{FG}{Should it not be $2^n -1$ times?}
% \edcomm{WK}{Yes --- I was just thinking of $z_n$. Why is choose with $n$ variables not just making $n$ choices?}\edcomm{FG}{ $P$ cannot be called without all its arguments. so we cannot choose $x_1$ without $x_2, \ldots, x_n$. However $x_2, \ldots, x_n$ don't exist prior to choosing $x_1$. so we need to use a nested choose statement to obtain them.}
% \edcomm{WK}{Why not just choose once, a G\"odel number for en $n$-tuple?}
% \edcomm{FG}{You are right, this can be done using the G\"odel number for the tuples (I would still need to construct the decoding procedure for this) \ldots since I have little time left (I need to submit my draft by March 3rd), I will come back to this after I finish section 5?}

\paragraph*{\large Choosing rational Values.}
Definition \ref{def::whileCCsyntax} does not support choosing a real value.
However, as mentioned in \citet{AbstractVSConcreteComputationOnMetricPartialAlgebras_TuckerZucker_2004}, we can extend our programming language in a conservative manner to allow choosing a rational value.

In this thesis, we simulate choosing a real value by choosing a numerator and a denominator (both of type $\nat$), and then using division and multiplication by $-1$ to construct a $\real$ value. Clearly, this construction will only give us rational values.
 % Choosing multiple values at a time containing real
% for $\chooseOp$ for multiple distinct variables, which stands for
% \begin{lstlisting}[escapeinside=||]
%     |$x_{1}$| := choose (|$z_{1}$|:|$s_{1}$|) : choose (|$z_2$|:|$s_{2}$|,|$\ldots$|,|$z_n$|:|$s_{n}$|) : ProcP(|$\bar{z}$|,|$\bar{t}$|)
%     |$x_{2}$|,|$\ldots $|,|$x_{n}$| := choose (|$z_{2}$|:|$s_{2}$|,|$\ldots$|,|$z_n$|:|$s_{n}$|) : ProcP(|$x_{1}$|,|$z_{2}$|,|$\ldots $|,|$z_{n}$|,|$\bar{t}$|)
% \end{lstlisting}
% where $\bar{s_i} \in \{ \nat, \real \}$.
% Note that this notation is defined recursively i.e. $\chooseOp$ with $n$ variables is defined in terms of $\chooseOp$ with $n-1$ variables.


Let $P$ be a procedure of type $\real \times s_1 \times \cdots \times s_n \to \bool$. We define 
\[
    x := \chooseOp \ (q:\real) : P(q, \bar{t})
\]
as a shorthand for 
\[
    x := \mathsf{ChooseRationalSuchThatP}(\bar{t}),
\]
where the procedure $\mathsf{ChooseRationalSuchThatP}$ is defined below:

\begingroup
\newcommand\sign{\mathit{sign}}

\[
\BLOCK{
\mathsf{ChooseRationalSuchThatP} \equiv \\
    \INDENT{
    \PROC \\
        \INDENT{
        \IN \bar{t}:\bar{s}\\
        \OUT q: real \\
        \AUX n_1:\nat\ n_2:\nat\ \sign:\nat}\\
    \BEGIN \\
        \BLOCK{
        \sign, n_1, n_2 := \CHOOSE \BLOCK{ (k:\nat,k_1:\nat,k_2:\nat) : \\
                                \PROC \\
                                    \INDENT{
                                    \IN k:\nat,\ k_1:\nat,\ k_2:\nat \\
                                    \OUT res:bool \\
                                    \AUX} \\
                                \BEGIN     \\
                                    \INDENT{
                                    \IF k \natEq 0 \THEN \\
                                        \INDENT{
                                        res := P(k_1/(k_2+1),\bar{t})}\\
                                    \ELSE \\
                                        \INDENT{
                                        res := P(-k_1/(k_2+1),\bar{t})} \\
                                    \FI} \\
                                \END(k, k_1, k_2)} \\
        \IF \sign \natEq 0 \THEN \\
            \INDENT{
            q := n_1/(n_2+1)} \\
        \ELSE \\
            \INDENT{
            q := -n_1/(n_2+1)} \\
        \FI }\\
    \END\\}}
\]
\endgroup


\medbreak
\noindent
We extend our $\chooseOp$ syntax to support multiple $\real$ variables in the same way we extend our syntax to support multiple $\nat$ variables. 
\paragraph*{\large The $\returnOp$ Statement.}
We alternatively write programs with one output variable, omitting the $\mathsf{out}$ clause and writing a $\returnOp$ statement at the last line. The procedure
\[
        \BLOCK{
        \PROC  \\
            \INDENT{
            \IN \ldots \\
            \AUX \ldots}\\
        \BEGIN \\
            \INDENT{
            \ldots \\
            \RETURN t}\\
        \END}      \\
\]
is a shorthand for the following:
\[  \BLOCK{
        \PROC  \\
            \INDENT{
            \IN \ldots \\
            \OUT r:s \\
            \AUX \ldots}\\
        \BEGIN \\
            \INDENT{
            \ldots \\
            r := t}\\
        \END}
\]

Note that the type of the output variable is inferred from the type of $t$.

